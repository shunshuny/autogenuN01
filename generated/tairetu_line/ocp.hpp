// This file was automatically generated by autogenu-jupyter (https://github.com/mayataka/autogenu-jupyter). 
// The autogenu-jupyter copyright holders make no ownership claim of its contents. 

#ifndef CGMRES__OCP_TAIRETU_LINE_HPP_ 
#define CGMRES__OCP_TAIRETU_LINE_HPP_ 
 
#define _USE_MATH_DEFINES

#include <cmath>
#include <array>
#include <iostream>

#include "cgmres/types.hpp"
#include "cgmres/detail/macros.hpp"

namespace cgmres {

/// 
/// @class OCP_tairetu_line
/// @brief Definition of the optimal control problem (OCP) of tairetu_line.
/// 
class OCP_tairetu_line { 
public:
  ///
  /// @brief Dimension of the state. 
  ///
  static constexpr int nx = 27;
 
  ///
  /// @brief Dimension of the control input. 
  ///
  static constexpr int nu = 6;
 
  ///
  /// @brief Dimension of the equality constraints. 
  ///
  static constexpr int nc = 0;
 
  ///
  /// @brief Dimension of the Fischer-Burmeister function (already counded in nc). 
  ///
  static constexpr int nh = 0;
 
  ///
  /// @brief Dimension of the concatenation of the control input and equality constraints. 
  ///
  static constexpr int nuc = nu + nc;

  ///
  /// @brief Dimension of the bound constraints on the control input. 
  ///
  static constexpr int nub = 0;

  double q11 = 100;
  double q12 = 100;
  double q21 = 100;
  double q22 = 100;
  double q31 = 100;
  double q32 = 100;
  double r11 = 100;
  double r12 = 30;
  double r21 = 100;
  double r22 = 100;
  double r23 = 30;
  double r31 = 100;
  double r32 = 100;
  double r33 = 30;
  double sf11 = 10;
  double sf12 = 10;
  double sf21 = 1;
  double sf22 = 1;
  double sf31 = 1;
  double sf32 = 1;
  double D = 5;
  double Length = 0.5;
  double A = sqrt(2);


  void disp(std::ostream& os) const {
    os << "OCP_tairetu_line:" << std::endl;
    os << "  nx:  " << nx << std::endl;
    os << "  nu:  " << nu << std::endl;
    os << "  nc:  " << nc << std::endl;
    os << "  nh:  " << nh << std::endl;
    os << "  nuc: " << nuc << std::endl;
    os << "  nub: " << nub << std::endl;
    os << std::endl;
    os << "  q11: " << q11 << std::endl;
    os << "  q12: " << q12 << std::endl;
    os << "  q21: " << q21 << std::endl;
    os << "  q22: " << q22 << std::endl;
    os << "  q31: " << q31 << std::endl;
    os << "  q32: " << q32 << std::endl;
    os << "  r11: " << r11 << std::endl;
    os << "  r12: " << r12 << std::endl;
    os << "  r21: " << r21 << std::endl;
    os << "  r22: " << r22 << std::endl;
    os << "  r23: " << r23 << std::endl;
    os << "  r31: " << r31 << std::endl;
    os << "  r32: " << r32 << std::endl;
    os << "  r33: " << r33 << std::endl;
    os << "  sf11: " << sf11 << std::endl;
    os << "  sf12: " << sf12 << std::endl;
    os << "  sf21: " << sf21 << std::endl;
    os << "  sf22: " << sf22 << std::endl;
    os << "  sf31: " << sf31 << std::endl;
    os << "  sf32: " << sf32 << std::endl;
    os << "  D: " << D << std::endl;
    os << "  Length: " << Length << std::endl;
    os << "  A: " << A << std::endl;
    os << std::endl;
    Eigen::IOFormat fmt(4, 0, ", ", "", "[", "]");
    Eigen::IOFormat intfmt(1, 0, ", ", "", "[", "]");
  }

  friend std::ostream& operator<<(std::ostream& os, const OCP_tairetu_line& ocp) { 
    ocp.disp(os);
    return os;
  }


  ///
  /// @brief Synchrozies the internal parameters of this OCP with the external references.
  /// This method is called at the beginning of each MPC update.
  ///
  void synchronize() {
  }

  ///
  /// @brief Computes the state equation dx = f(t, x, u).
  /// @param[in] t Time.
  /// @param[in] x State.
  /// @param[in] u Control input.
  /// @param[out] dx Evaluated value of the state equation.
  /// @remark This method is intended to be used inside of the cgmres solvers and does not check size of each argument. 
  /// Use the overloaded method if you call this outside of the cgmres solvers. 
  ///
  void eval_f(const double t, const double* x, const double* u, 
              double* dx) const {
    dx[0] = u[0]*cos(x[2]);
    dx[1] = u[0]*sin(x[2]);
    dx[2] = u[0]*tan(u[1])/Length;
    dx[3] = u[2]*cos(x[5]);
    dx[4] = u[2]*sin(x[5]);
    dx[5] = u[2]*tan(u[3])/Length;
    dx[6] = u[4]*cos(x[8]);
    dx[7] = u[4]*sin(x[8]);
    dx[8] = u[4]*tan(u[5])/Length;
    dx[9] = u[0]*cos(x[2]);
    dx[10] = u[0]*sin(x[2]);
    dx[11] = u[0]*tan(u[1])/Length;
    dx[12] = u[2]*cos(x[5]);
    dx[13] = u[2]*sin(x[5]);
    dx[14] = u[2]*tan(u[3])/Length;
    dx[15] = u[4]*cos(x[8]);
    dx[16] = u[4]*sin(x[8]);
    dx[17] = u[4]*tan(u[5])/Length;
    dx[18] = u[0]*cos(x[2]);
    dx[19] = u[0]*sin(x[2]);
    dx[20] = u[0]*tan(u[1])/Length;
    dx[21] = u[2]*cos(x[5]);
    dx[22] = u[2]*sin(x[5]);
    dx[23] = u[2]*tan(u[3])/Length;
    dx[24] = u[4]*cos(x[8]);
    dx[25] = u[4]*sin(x[8]);
    dx[26] = u[4]*tan(u[5])/Length;
 
  }

  ///
  /// @brief Computes the partial derivative of terminal cost with respect to state, 
  /// i.e., phix = dphi/dx(t, x).
  /// @param[in] t Time.
  /// @param[in] x State.
  /// @param[out] phix Evaluated value of the partial derivative of terminal cost.
  /// @remark This method is intended to be used inside of the cgmres solvers and does not check size of each argument. 
  /// Use the overloaded method if you call this outside of the cgmres solvers. 
  ///
  void eval_phix(const double t, const double* x, double* phix) const {
    phix[0] = sf11*(-2*t + 2*x[0]);
    phix[1] = sf12*(2*x[1] - 8);
    phix[2] = 0;
    phix[3] = 0;
    phix[4] = 0;
    phix[5] = 0;
    phix[6] = 0;
    phix[7] = 0;
    phix[8] = 0;
    phix[9] = sf21*(x[0] - x[3])/sqrt(pow(-x[0] + x[3], 2) + pow(-x[1] + x[4], 2));
    phix[10] = sf21*(x[1] - x[4])/sqrt(pow(-x[0] + x[3], 2) + pow(-x[1] + x[4], 2));
    phix[11] = 0;
    phix[12] = sf21*(-x[0] + x[3])/sqrt(pow(-x[0] + x[3], 2) + pow(-x[1] + x[4], 2));
    phix[13] = sf21*(-x[1] + x[4])/sqrt(pow(-x[0] + x[3], 2) + pow(-x[1] + x[4], 2));
    phix[14] = 0;
    phix[15] = 0;
    phix[16] = 0;
    phix[17] = 0;
    phix[18] = 0;
    phix[19] = 0;
    phix[20] = 0;
    phix[21] = sf32*(x[3] - x[6])/sqrt(pow(-x[3] + x[6], 2) + pow(-x[4] + x[7], 2));
    phix[22] = sf32*(x[4] - x[7])/sqrt(pow(-x[3] + x[6], 2) + pow(-x[4] + x[7], 2));
    phix[23] = 0;
    phix[24] = sf32*(-x[3] + x[6])/sqrt(pow(-x[3] + x[6], 2) + pow(-x[4] + x[7], 2));
    phix[25] = sf32*(-x[4] + x[7])/sqrt(pow(-x[3] + x[6], 2) + pow(-x[4] + x[7], 2));
    phix[26] = 0;
 
  }

  ///
  /// @brief Computes the partial derivative of the Hamiltonian with respect to state, 
  /// i.e., hx = dH/dx(t, x, u, lmd).
  /// @param[in] t Time.
  /// @param[in] x State.
  /// @param[in] u Concatenatin of the control input and Lagrange multiplier with respect to the equality constraints. 
  /// @param[in] lmd Costate. 
  /// @param[out] hx Evaluated value of the partial derivative of the Hamiltonian.
  /// @remark This method is intended to be used inside of the cgmres solvers and does not check size of each argument. 
  /// Use the overloaded method if you call this outside of the cgmres solvers. 
  ///
  void eval_hx(const double t, const double* x, const double* u, 
               const double* lmd, double* hx) const {
    hx[0] = q11*(-2*t + 2*x[0]);
    hx[1] = q12*(2*x[1] - 8);
    hx[2] = -lmd[0]*u[0]*sin(x[2]) + lmd[1]*u[0]*cos(x[2]);
    hx[3] = 0;
    hx[4] = 0;
    hx[5] = -lmd[3]*u[2]*sin(x[5]) + lmd[4]*u[2]*cos(x[5]);
    hx[6] = 0;
    hx[7] = 0;
    hx[8] = -lmd[6]*u[4]*sin(x[8]) + lmd[7]*u[4]*cos(x[8]);
    hx[9] = q21*(x[0] - x[3])/sqrt(pow(-x[0] + x[3], 2) + pow(-x[1] + x[4], 2));
    hx[10] = q21*(x[1] - x[4])/sqrt(pow(-x[0] + x[3], 2) + pow(-x[1] + x[4], 2));
    hx[11] = lmd[10]*u[0]*cos(x[2]) - lmd[9]*u[0]*sin(x[2]);
    hx[12] = q21*(-x[0] + x[3])/sqrt(pow(-x[0] + x[3], 2) + pow(-x[1] + x[4], 2));
    hx[13] = q21*(-x[1] + x[4])/sqrt(pow(-x[0] + x[3], 2) + pow(-x[1] + x[4], 2));
    hx[14] = -lmd[12]*u[2]*sin(x[5]) + lmd[13]*u[2]*cos(x[5]);
    hx[15] = 0;
    hx[16] = 0;
    hx[17] = -lmd[15]*u[4]*sin(x[8]) + lmd[16]*u[4]*cos(x[8]);
    hx[18] = 0;
    hx[19] = 0;
    hx[20] = -lmd[18]*u[0]*sin(x[2]) + lmd[19]*u[0]*cos(x[2]);
    hx[21] = q32*(x[3] - x[6])/sqrt(pow(-x[3] + x[6], 2) + pow(-x[4] + x[7], 2));
    hx[22] = q32*(x[4] - x[7])/sqrt(pow(-x[3] + x[6], 2) + pow(-x[4] + x[7], 2));
    hx[23] = -lmd[21]*u[2]*sin(x[5]) + lmd[22]*u[2]*cos(x[5]);
    hx[24] = q32*(-x[3] + x[6])/sqrt(pow(-x[3] + x[6], 2) + pow(-x[4] + x[7], 2));
    hx[25] = q32*(-x[4] + x[7])/sqrt(pow(-x[3] + x[6], 2) + pow(-x[4] + x[7], 2));
    hx[26] = -lmd[24]*u[4]*sin(x[8]) + lmd[25]*u[4]*cos(x[8]);
 
  }

  ///
  /// @brief Computes the partial derivative of the Hamiltonian with respect to control input and the equality constraints, 
  /// i.e., hu = dH/du(t, x, u, lmd).
  /// @param[in] t Time.
  /// @param[in] x State.
  /// @param[in] u Concatenatin of the control input and Lagrange multiplier with respect to the equality constraints. 
  /// @param[in] lmd Costate. 
  /// @param[out] hu Evaluated value of the partial derivative of the Hamiltonian.
  /// @remark This method is intended to be used inside of the cgmres solvers and does not check size of each argument. 
  /// Use the overloaded method if you call this outside of the cgmres solvers. 
  ///
  void eval_hu(const double t, const double* x, const double* u, 
               const double* lmd, double* hu) const {
    hu[0] = lmd[0]*cos(x[2]) + lmd[1]*sin(x[2]) + r11*(-2*A + 2*u[0]) + lmd[2]*tan(u[1])/Length;
    hu[1] = 2*r12*u[1] + lmd[2]*u[0]*(pow(tan(u[1]), 2) + 1)/Length;
    hu[2] = lmd[12]*cos(x[5]) + lmd[13]*sin(x[5]) + r21*(-2*u[0] + 2*u[2]) + r22*(2*u[2] - 2*u[4]) + lmd[14]*tan(u[3])/Length;
    hu[3] = 2*r23*u[3] + lmd[14]*u[2]*(pow(tan(u[3]), 2) + 1)/Length;
    hu[4] = lmd[24]*cos(x[8]) + lmd[25]*sin(x[8]) + r31*(-2*u[0] + 2*u[4]) + r32*(-2*u[2] + 2*u[4]) + lmd[26]*tan(u[5])/Length;
    hu[5] = 2*r33*u[5] + lmd[26]*u[4]*(pow(tan(u[5]), 2) + 1)/Length;
 
  }

  ///
  /// @brief Computes the state equation dx = f(t, x, u).
  /// @param[in] t Time.
  /// @param[in] x State. Size must be nx.
  /// @param[in] u Control input. Size must be nu.
  /// @param[out] dx Evaluated value of the state equation. Size must be nx.
  ///
  template <typename VectorType1, typename VectorType2, typename VectorType3>
  void eval_f(const double t, const MatrixBase<VectorType1>& x, 
              const MatrixBase<VectorType2>& u, 
              const MatrixBase<VectorType3>& dx) const {
    if (x.size() != nx) {
      throw std::invalid_argument("[OCP]: x.size() must be " + std::to_string(nx));
    }
    if (u.size() != nu) {
      throw std::invalid_argument("[OCP]: u.size() must be " + std::to_string(nu));
    }
    if (dx.size() != nx) {
      throw std::invalid_argument("[OCP]: dx.size() must be " + std::to_string(nx));
    }
    eval_f(t, x.derived().data(), u.derived().data(), CGMRES_EIGEN_CONST_CAST(VectorType3, dx).data());
  }

  ///
  /// @brief Computes the partial derivative of terminal cost with respect to state, 
  /// i.e., phix = dphi/dx(t, x).
  /// @param[in] t Time.
  /// @param[in] x State. Size must be nx.
  /// @param[out] phix Evaluated value of the partial derivative of terminal cost. Size must be nx.
  ///
  template <typename VectorType1, typename VectorType2>
  void eval_phix(const double t, const MatrixBase<VectorType1>& x, 
                 const MatrixBase<VectorType2>& phix) const {
    if (x.size() != nx) {
      throw std::invalid_argument("[OCP]: x.size() must be " + std::to_string(nx));
    }
    if (phix.size() != nx) {
      throw std::invalid_argument("[OCP]: phix.size() must be " + std::to_string(nx));
    }
    eval_phix(t, x.derived().data(), CGMRES_EIGEN_CONST_CAST(VectorType2, phix).data());
  }

  ///
  /// @brief Computes the partial derivative of the Hamiltonian with respect to the state, 
  /// i.e., hx = dH/dx(t, x, u, lmd).
  /// @param[in] t Time.
  /// @param[in] x State. Size must be nx.
  /// @param[in] uc Concatenatin of the control input and Lagrange multiplier with respect to the equality constraints. Size must be nuc. 
  /// @param[in] lmd Costate.  Size must be nx.
  /// @param[out] hx Evaluated value of the partial derivative of the Hamiltonian. Size must be nx.
  ///
  template <typename VectorType1, typename VectorType2, typename VectorType3, typename VectorType4>
  void eval_hx(const double t, const MatrixBase<VectorType1>& x, 
               const MatrixBase<VectorType2>& uc, 
               const MatrixBase<VectorType3>& lmd, 
               const MatrixBase<VectorType4>& hx) const {
    if (x.size() != nx) {
      throw std::invalid_argument("[OCP]: x.size() must be " + std::to_string(nx));
    }
    if (uc.size() != nuc) {
      throw std::invalid_argument("[OCP]: uc.size() must be " + std::to_string(nuc));
    }
    if (lmd.size() != nx) {
      throw std::invalid_argument("[OCP]: lmd.size() must be " + std::to_string(nx));
    }
    if (hx.size() != nuc) {
      throw std::invalid_argument("[OCP]: hx.size() must be " + std::to_string(nx));
    }
    eval_hx(t, x.derived().data(), uc.derived().data(), lmd.derived().data(), CGMRES_EIGEN_CONST_CAST(VectorType4, hx).data());
  }

  ///
  /// @brief Computes the partial derivative of the Hamiltonian with respect to control input and the equality constraints, 
  /// i.e., hu = dH/du(t, x, u, lmd).
  /// @param[in] t Time.
  /// @param[in] x State. Size must be nx.
  /// @param[in] uc Concatenatin of the control input and Lagrange multiplier with respect to the equality constraints. Size must be nuc. 
  /// @param[in] lmd Costate. Size must be nx. 
  /// @param[out] hu Evaluated value of the partial derivative of the Hamiltonian. Size must be nuc.
  ///
  template <typename VectorType1, typename VectorType2, typename VectorType3, typename VectorType4>
  void eval_hu(const double t, const MatrixBase<VectorType1>& x, 
               const MatrixBase<VectorType2>& uc, 
               const MatrixBase<VectorType3>& lmd, 
               const MatrixBase<VectorType4>& hu) const {
    if (x.size() != nx) {
      throw std::invalid_argument("[OCP]: x.size() must be " + std::to_string(nx));
    }
    if (uc.size() != nuc) {
      throw std::invalid_argument("[OCP]: uc.size() must be " + std::to_string(nuc));
    }
    if (lmd.size() != nx) {
      throw std::invalid_argument("[OCP]: lmd.size() must be " + std::to_string(nx));
    }
    if (hu.size() != nuc) {
      throw std::invalid_argument("[OCP]: hu.size() must be " + std::to_string(nuc));
    }
    eval_hu(t, x.derived().data(), uc.derived().data(), lmd.derived().data(), CGMRES_EIGEN_CONST_CAST(VectorType4, hu).data());
  }

};

} // namespace cgmres

#endif // CGMRES_OCP_HPP_
